<center><h1> Redis 事务 </h1></center>

## 1. 介绍
&#160; &#160; &#160; &#160; Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：

- 批量操作在发送 EXEC 命令前被放入队列缓存。
- 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。

&#160; &#160; &#160; &#160; 一个事务从开始到执行会经历以下三个阶段

- 开始事务。
- 命令入队。
- 执行事务。

## 2. 事务命令

序号|命令|描述
---|---|---
1|DISCARD |取消事务，放弃执行事务块内的所有命令。
2|EXEC |执行所有事务块内的命令。
3|MULTI |标记一个事务块的开始。
4|UNWATCH |取消 WATCH 命令对所有 key 的监视。
5|WATCH key [key ...] |监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。

## 3. 实例

&#160; &#160; &#160; &#160; 以下是一个事务的例子， 它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令：

```
127.0.0.1:6379> select 6
(error) NOAUTH Authentication required.
127.0.0.1:6379> AUTH cmz
OK
127.0.0.1:6379> select 6
OK
127.0.0.1:6379[6]> MULTI
OK
127.0.0.1:6379[6]> EXEC
(empty list or set)
127.0.0.1:6379[6]> set k1 1
OK
127.0.0.1:6379[6]> set k2 2
OK
127.0.0.1:6379[6]> set k3 3
OK
127.0.0.1:6379[6]> keys *
1) "k3"
2) "k2"
3) "k1"
127.0.0.1:6379[6]> MGET k1 k2 k3
1) "1"
2) "2"
3) "3"
127.0.0.1:6379[6]> MULTI
OK
127.0.0.1:6379[6]> set k1 11
QUEUED
127.0.0.1:6379[6]> set k2 22
QUEUED
127.0.0.1:6379[6]> set k3 33
QUEUED
127.0.0.1:6379[6]> EXEC
1) OK
2) OK
3) OK
127.0.0.1:6379[6]> MGET k1 k2 k3
1) "11"
2) "22"
3) "33"

```

!!! danger "注意"
    ```python
    单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。
    
    事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。
    ```


```
127.0.0.1:6379[6]> MULTI
OK
127.0.0.1:6379[6]> set a aaa
QUEUED
127.0.0.1:6379[6]> set b bbb
QUEUED
127.0.0.1:6379[6]> set c ccc
QUEUED
127.0.0.1:6379[6]> exec
1) OK
2) OK
3) OK
```
如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。
